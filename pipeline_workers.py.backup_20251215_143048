# pipeline_workers.py (v5.9.3 - æ¢å¤åŸå§‹gitç‰ˆæœ¬ï¼Œç®€åŒ–è¯Šæ–­æ—¥å¿—)
import subprocess
import json
import sys
import locale
import traceback
from pathlib import Path
from utils import file_cleaner, run_silent, run_ffmpeg_with_progress
import psutil
import gc
import time
import os
import shutil  # æ·»åŠ shutilç”¨äºæ–‡ä»¶å¤åˆ¶
from silero_manager import ensure_silero_for_ffsubsync  # Sileroæ¨¡å‹ç®¡ç†

def _ratio_to_float(ratio_str: str) -> float:
    """å°†å¸§ç‡æ¯”ç‡å­—ç¬¦ä¸²è½¬æ¢ä¸ºæµ®ç‚¹æ•° (å¦‚ "30/1" -> 30.0)"""
    try:
        if '/' in ratio_str:
            numerator, denominator = ratio_str.split('/')
            denominator_val = float(denominator)
            if denominator_val != 0:
                return float(numerator) / denominator_val
        return float(ratio_str)
    except (ValueError, ZeroDivisionError, AttributeError):
        return 0.0

def monitor_memory_usage(func_name: str, log_queue) -> float:
    """ç›‘æ§å†…å­˜ä½¿ç”¨å¹¶è®°å½•"""
    try:
        process = psutil.Process(os.getpid())
        memory_mb = process.memory_info().rss / 1024 / 1024
        log_queue.put(f" [å†…å­˜] {func_name}: {memory_mb:.1f} MB")
        return memory_mb
    except:
        return 0.0

def force_garbage_collection(log_queue, threshold_mb: float = 1000):
    """å¼ºåˆ¶åƒåœ¾å›æ”¶"""
    try:
        process = psutil.Process(os.getpid())
        memory_mb = process.memory_info().rss / 1024 / 1024
        if memory_mb > threshold_mb:
            log_queue.put(f" [å†…å­˜æ¸…ç†] å½“å‰ä½¿ç”¨ {memory_mb:.1f} MBï¼Œæ‰§è¡Œåƒåœ¾å›æ”¶...")
            gc.collect()
            new_memory_mb = process.memory_info().rss / 1024 / 1024
            freed_mb = memory_mb - new_memory_mb
            if freed_mb > 0:
                log_queue.put(f" [å†…å­˜æ¸…ç†] é‡Šæ”¾äº† {freed_mb:.1f} MB")
    except:
        pass

# --- åå¤„ç†è¾…åŠ©å‡½æ•° ---

def _build_ffprobe_command(ffprobe_cmd: str, media_path: str,
                           probesize: str | None, analyzeduration: str | None) -> list[str]:
    """Build ffprobe command parameters."""
    cmd: list[str] = [ffprobe_cmd, "-hide_banner"]
    if probesize:
        cmd.extend(["-probesize", probesize])
    if analyzeduration:
        cmd.extend(["-analyzeduration", analyzeduration])
    cmd.extend([
        "-v", "error",
        "-show_entries", "stream=avg_frame_rate,r_frame_rate,codec_name,codec_type:format=duration",
        "-of", "json",
        media_path,
    ])
    return cmd

def _probe_media_metadata(ffprobe_cmd: str, media_path: str, log_queue) -> tuple[dict | None, str | None, str | None]:
    """Run ffprobe with retries to gather media metadata."""
    attempts = [
        ("baseline", "æ ‡å‡†æ¢æµ‹", "10M", "10M"),
        ("extended", "æ‰©å±•æ¢æµ‹", "200M", "200M"),
        ("deep", "æ·±åº¦æ¢æµ‹", "0", "0"),
    ]
    last_error: str | None = None

    for idx, (_attempt_key, label_display, probesize, analyzeduration) in enumerate(attempts):
        cmd = _build_ffprobe_command(ffprobe_cmd, media_path, probesize, analyzeduration)
        try:
            result = run_silent(cmd, check=False, timeout=45)
        except FileNotFoundError as fnf_err:
            return None, None, f"æœªæ‰¾åˆ° ffprobe å¯æ‰§è¡Œæ–‡ä»¶: {fnf_err}"
        except subprocess.TimeoutExpired:
            last_error = "æ¢æµ‹è¶…æ—¶"
            if log_queue is not None and idx < len(attempts) - 1:
                log_queue.put(f"      - âš ï¸ FFProbeç¬¬{idx + 1}è½®è¶…æ—¶({label_display})ï¼Œè°ƒæ•´å‚æ•°åé‡è¯•")
            continue
        except Exception as unexpected_err:
            return None, None, f"è°ƒç”¨ ffprobe å¤±è´¥: {unexpected_err}"

        if result.returncode == 0:
            try:
                probe_data = json.loads(result.stdout)
                if idx > 0 and log_queue is not None:
                    log_queue.put(f"      - â„¹ï¸ FFProbeåœ¨ç¬¬{idx + 1}è½®({label_display})æˆåŠŸ")
                return probe_data, label_display, None
            except json.JSONDecodeError as json_err:
                last_error = f"è¾“å‡ºè§£æå¤±è´¥: {json_err}"
        else:
            stderr = (result.stderr or '').strip()
            if stderr:
                stderr = stderr.splitlines()[-1]
            last_error = stderr or f"é€€å‡ºç  {result.returncode}"
            if log_queue is not None and idx < len(attempts) - 1:
                log_queue.put(f"      - âš ï¸ FFProbeç¬¬{idx + 1}è½®å¤±è´¥({label_display}): {last_error}")

    return None, None, last_error
def _format_srt_time(ms: int) -> str:
    """å°†æ¯«ç§’è½¬æ¢ä¸ºSRTæ—¶é—´æ ¼å¼"""
    seconds, milliseconds = divmod(ms, 1000)
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    return f"{int(hours):02d}:{int(minutes):02d}:{int(seconds):02d},{int(milliseconds):03d}"

def _write_srt_from_result(rec_result: list, output_path: str):
    """
    æ ¹æ®è¯†åˆ«ç»“æœå†™å…¥SRTæ–‡ä»¶ (å·²ä¿®å¤ç´¢å¼•é”™è¯¯å¹¶å¢åŠ å…¼å®¹æ€§)
    """
    if not rec_result or not isinstance(rec_result, list) or len(rec_result) == 0:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("")
        return

    first_item = rec_result[0]
    sentence_info = first_item.get('sentence_info')

    # ä¼˜å…ˆä½¿ç”¨ sentence_info
    if sentence_info and isinstance(sentence_info, list):
        with open(output_path, 'w', encoding='utf-8') as f:
            for i, sentence_data in enumerate(sentence_info):
                start_time = _format_srt_time(sentence_data['start'])
                end_time = _format_srt_time(sentence_data['end'])
                text = sentence_data.get('text', '').strip()
                if text:
                    f.write(f"{i + 1}\n")
                    f.write(f"{start_time} --> {end_time}\n")
                    f.write(f"{text}\n\n")
    # å¦‚æœæ²¡æœ‰ sentence_infoï¼Œå°è¯•ä½¿ç”¨ 'timestamp' å’Œ 'text' å­—æ®µ
    elif 'timestamp' in first_item and 'text' in first_item:
        with open(output_path, 'w', encoding='utf-8') as f:
            full_text = first_item.get('text', '').strip()
            if full_text:
                timestamps = first_item.get('timestamp', [])
                start_ms = timestamps[0][0] if timestamps and len(timestamps) > 0 else 0
                end_ms = timestamps[0][1] if timestamps and len(timestamps) > 0 and len(timestamps[0]) > 1 else 1000 # é»˜è®¤1ç§’

                start_time = _format_srt_time(start_ms)
                end_time = _format_srt_time(end_ms)

                f.write("1\n")
                f.write(f"{start_time} --> {end_time}\n")
                f.write(f"{full_text}\n\n")
    else:
        # å¦‚æœä¸¤ç§æ ¼å¼éƒ½æ— æ•ˆï¼Œåˆ™åˆ›å»ºä¸€ä¸ªç©ºçš„SRTæ–‡ä»¶
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("")

# --- æµæ°´çº¿é˜¶æ®µ 1ï¼šé¢„å¤„ç† (CPU) ---
def pre_processing_worker(task_queue, audio_queue, log_queue, progress_queue, config, ffmpeg_semaphore, pause_event=None):
    from ffmpeg_manager import get_ffmpeg_path, get_ffprobe_path
    FFMPEG_CMD = get_ffmpeg_path()
    FFPROBE_CMD = get_ffprobe_path()

    while True:
        if pause_event is not None:
            pause_event.wait()
        try:
            original_file_path = task_queue.get(timeout=1)
        except Exception:
            break

        p_original = Path(original_file_path)
        log_queue.put(f"   [é¢„å¤„ç†] å¼€å§‹å¤„ç†: {p_original.name}")

        # æ€§èƒ½è®¡æ—¶
        t_start = time.time()
        t_ffprobe = 0
        t_cfr = 0
        t_extract = 0

        try:
            video_to_process = original_file_path

            # ã€ä¿®å¤ã€‘åœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½åˆå§‹åŒ–å˜é‡å¹¶è·å–è§†é¢‘æ—¶é•¿
            total_duration_ms = 0
            stream_info = None

            # è·å–è§†é¢‘æ—¶é•¿ï¼ˆç”¨äºè¿›åº¦æ˜¾ç¤ºï¼‰
            t_probe_start = time.time()
            with ffmpeg_semaphore:
                probe_data, probe_label, probe_error = _probe_media_metadata(FFPROBE_CMD, original_file_path, log_queue)

            if probe_data:
                try:
                    all_streams = probe_data.get('streams', [])
                    format_info = probe_data.get('format', {})

                    duration_s = float(format_info.get('duration', 0))
                    total_duration_ms = int(duration_s * 1000)

                    video_stream = None
                    audio_stream = None
                    for stream in all_streams:
                        codec_type = stream.get('codec_type', '')
                        if codec_type == 'video' and video_stream is None:
                            video_stream = stream
                        elif codec_type == 'audio' and audio_stream is None:
                            audio_stream = stream

                    stream_info = video_stream

                    if audio_stream:
                        log_queue.put(f"      - âœ… éŸ³é¢‘æµæ£€æµ‹åˆ° {audio_stream.get('codec_name', 'unknown')}")
                    else:
                        log_queue.put("      - âš ï¸ è­¦å‘Š: æœªæ£€æµ‹åˆ°éŸ³é¢‘æµ")

                    if video_stream:
                        log_queue.put(f"      - âœ… è§†é¢‘æµæ£€æµ‹åˆ° {video_stream.get('codec_name', 'unknown')}")
                    else:
                        log_queue.put("      - âš ï¸ è­¦å‘Š: æœªæ£€æµ‹åˆ°è§†é¢‘æµ")
                except (KeyError, ValueError, TypeError) as parse_err:
                    stream_info = None
                    log_queue.put(f"      - âš ï¸ FFProbeç»“æœè§£æå¼‚å¸¸: {parse_err}")
            else:
                stream_info = None
                if probe_error:
                    log_queue.put(f"      - âš ï¸ FFProbeè§£æå¤±è´¥: {probe_error}")
                if total_duration_ms == 0:
                    try:
                        audio_path_fallback = p_original.with_name(f"{p_original.stem}_extracted.wav")
                        if audio_path_fallback.exists():
                            sz = audio_path_fallback.stat().st_size
                            total_duration_ms = int((sz / 32000.0) * 1000)
                            log_queue.put(f"      - ä½¿ç”¨éŸ³é¢‘æ–‡ä»¶å¤§å°ä¼°ç®—æ—¶é•¿: {total_duration_ms}ms")
                    except Exception:
                        pass
            t_ffprobe = time.time() - t_probe_start

            if config['cfr_enabled'] and p_original.suffix.lower() in config['supported_video_ext']:
                cfr_output_path = p_original.parent / f"{p_original.stem}_CFR.mp4"
                log_queue.put(f"      - æ­£åœ¨æ£€æŸ¥æ˜¯å¦éœ€è¦CFRè½¬æ¢...")

                # å¦‚æœæˆåŠŸè·å–åˆ°è§†é¢‘æµä¿¡æ¯ï¼Œä½¿ç”¨æ•°å€¼åŒ–æ–¹å¼æ£€æŸ¥æ˜¯å¦æ˜¯å¯å˜å¸§ç‡ (VFR)
                is_vfr = False
                target_fps = 30  # é»˜è®¤ç›®æ ‡å¸§ç‡
                if stream_info:
                    avg_fr = _ratio_to_float(stream_info.get('avg_frame_rate', '0/1'))
                    r_fr = _ratio_to_float(stream_info.get('r_frame_rate', '0/1'))
                    # ä½¿ç”¨æµ®ç‚¹æ•°æ¯”è¾ƒï¼Œå®¹è®¸å¾®å°è¯¯å·®
                    is_vfr = abs(avg_fr - r_fr) > 1e-6
                    # æ™ºèƒ½é€‰æ‹©ç›®æ ‡å¸§ç‡ï¼ˆå››èˆäº”å…¥æºå¸§ç‡ï¼‰
                    if r_fr > 0:
                        target_fps = round(r_fr)

                if is_vfr:
                    log_queue.put(f"      - æ£€æµ‹åˆ°VFRï¼Œå¼€å§‹è½¬æ¢åˆ° {target_fps} fps...")
                    device = config.get('device', 'cpu')

                    conversion_successful = False
                    t_cfr_start = time.time()

                    # --- æ­¥éª¤1: ä¼˜å…ˆå°è¯•ç¡¬ä»¶åŠ é€Ÿè½¬æ¢ (å¦‚æœä½¿ç”¨CUDA) ---
                    if device == 'cuda':
                        try:
                            log_queue.put("         -> å°è¯•1/2: ä½¿ç”¨NVIDIA NVENCç¡¬ä»¶åŠ é€Ÿ...")
                            with ffmpeg_semaphore:  # ä½¿ç”¨ä¿¡å·é‡é™æµ
                                cfr_cmd = [
                                    "-hwaccel", "auto",  # è®©FFmpegè‡ªåŠ¨é€‰æ‹©ç¡¬ä»¶åŠ é€Ÿ
                                    "-i", original_file_path,
                                    "-vf", f"fps={target_fps}",
                                    "-c:v", "h264_nvenc", "-preset", "p1", "-cq", "23", "-pix_fmt", "yuv420p",
                                    "-c:a", "copy", "-threads", "2", "-y", str(cfr_output_path)
                                ]

                                rc = run_silent([FFMPEG_CMD, "-nostdin", "-hide_banner", "-loglevel", "error"] + cfr_cmd, check=True)

                            video_to_process = str(cfr_output_path)
                            log_queue.put(f"      - âœ… ç¡¬ä»¶åŠ é€ŸCFRè½¬æ¢æˆåŠŸ: {cfr_output_path.name}")
                            conversion_successful = True

                        except subprocess.CalledProcessError as hw_error:
                            error_details = hw_error.stderr.strip().splitlines()[-2:] if hw_error.stderr else [str(hw_error)]
                            log_queue.put(f"      - âš ï¸ ç¡¬ä»¶åŠ é€Ÿè½¬æ¢å¤±è´¥ã€‚é”™è¯¯: {error_details}")
                            log_queue.put("         -> å°†è‡ªåŠ¨åˆ‡æ¢åˆ°CPUæ¨¡å¼é‡è¯•...")

                    # --- æ­¥éª¤2: å¦‚æœç¡¬ä»¶è½¬æ¢å¤±è´¥æˆ–æœªå¯ç”¨ï¼Œåˆ™ä½¿ç”¨CPUè¿›è¡Œè½¬æ¢ ---
                    if not conversion_successful:
                        log_queue.put("         -> å°è¯•2/2: ä½¿ç”¨CPUè¿›è¡Œè½¬æ¢ (æ›´ç¨³å®š)...")
                        with ffmpeg_semaphore:  # ä½¿ç”¨ä¿¡å·é‡é™æµ
                            cfr_cmd = [
                                "-i", original_file_path,
                                "-vf", f"fps={target_fps}",
                                "-c:v", "libx264", "-preset", "ultrafast", "-crf", "23",
                                "-c:a", "copy", "-threads", "2", "-y", str(cfr_output_path)
                            ]

                            # ä½¿ç”¨ run_silent é¿å…é»‘çª—
                            rc = run_silent([FFMPEG_CMD, "-nostdin", "-hide_banner", "-loglevel", "error"] + cfr_cmd, check=True)

                        video_to_process = str(cfr_output_path)
                        log_queue.put(f"      - âœ… CPUæ¨¡å¼CFRè½¬æ¢æˆåŠŸ: {cfr_output_path.name}")

                    t_cfr = time.time() - t_cfr_start
                else:
                    log_queue.put(f"      - å·²æ˜¯CFRï¼Œè·³è¿‡è½¬æ¢ã€‚")

            # éŸ³é¢‘æå– - ä½¿ç”¨ä¿¡å·é‡é™æµå’Œå®æ—¶è¿›åº¦
            audio_output_path = p_original.with_name(f"{p_original.stem}_extracted.wav")

            t_extract_start = time.time()
            with ffmpeg_semaphore:  # ä½¿ç”¨ä¿¡å·é‡é™æµ
                # å‡†å¤‡éŸ³é¢‘æå–å‘½ä»¤ï¼ˆä¸åŒ…å« ffmpeg æœ¬ä½“ï¼‰
                extract_cmd = [
                    '-i', video_to_process,
                    '-map', 'a:0?', '-vn', '-sn', '-dn',
                    '-acodec', 'pcm_s16le', '-ac', '1', '-ar', '16000',
                    '-threads', '2',
                    '-y', str(audio_output_path)
                ]

                # å¦‚æœæœ‰æ—¶é•¿ä¿¡æ¯ï¼Œä½¿ç”¨å¸¦è¿›åº¦çš„ç‰ˆæœ¬
                if total_duration_ms > 0:
                    def emit_progress(event):
                        # å‘é€FFmpegè¿›åº¦äº‹ä»¶
                        event["file"] = str(p_original)
                        event["stage"] = "extract"
                        progress_queue.put(event)

                    rc = run_ffmpeg_with_progress(extract_cmd, total_duration_ms, emit_progress, FFMPEG_CMD)
                    if rc != 0:
                        raise RuntimeError(f"FFmpeg éŸ³é¢‘æå–å¤±è´¥ï¼Œè¿”å›ç : {rc}")
                else:
                    # é™çº§åˆ°æ™®é€šæ¨¡å¼ï¼ˆæ— è¿›åº¦ï¼‰
                    run_silent([FFMPEG_CMD, '-nostdin', '-hide_banner', '-loglevel', 'error'] + extract_cmd, check=True)

            t_extract = time.time() - t_extract_start

            # ã€æ–°å¢ã€‘éªŒè¯æå–çš„éŸ³é¢‘æ˜¯å¦æœ‰æ•ˆï¼ˆå¿«é€Ÿæ£€æµ‹é™éŸ³ï¼‰
            if audio_output_path.exists():
                audio_size = audio_output_path.stat().st_size
                log_queue.put(f"      - éŸ³é¢‘æ–‡ä»¶å¤§å°: {audio_size:,} å­—èŠ‚")

                # å¿«é€ŸéŸ³é‡æ£€æµ‹ï¼ˆä»…æ£€æŸ¥å‰10ç§’ï¼Œé¿å…è€—æ—¶è¿‡é•¿ï¼‰
                try:
                    with ffmpeg_semaphore:
                        volume_cmd = [
                            FFMPEG_CMD, "-nostdin", "-hide_banner",
                            "-t", "10",  # åªæ£€æŸ¥å‰10ç§’
                            "-i", str(audio_output_path),
                            "-af", "volumedetect",
                            "-f", "null", "-"
                        ]
                        volume_result = run_silent(volume_cmd, check=False)  # ä¸æŠ›å¼‚å¸¸

                        # ä»stderrä¸­æŸ¥æ‰¾mean_volume
                        if volume_result.stderr:
                            for line in volume_result.stderr.split('\n'):
                                if 'mean_volume:' in line:
                                    try:
                                        volume_str = line.split(':')[1].strip().split()[0]
                                        mean_volume = float(volume_str)
                                        log_queue.put(f"      - éŸ³é¢‘å¹³å‡éŸ³é‡: {mean_volume:.1f} dB")

                                        # è­¦å‘Šï¼šéŸ³é‡è¿‡ä½å¯èƒ½æ˜¯é™éŸ³æˆ–æŸå
                                        if mean_volume < -60:
                                            log_queue.put(f"      - âš ï¸âš ï¸âš ï¸ è­¦å‘Š: éŸ³é¢‘éŸ³é‡è¿‡ä½ ({mean_volume:.1f} dB)ï¼Œå¯èƒ½ä¸ºé™éŸ³æˆ–æŸåï¼")
                                            log_queue.put(f"      - å»ºè®®: ä½¿ç”¨ ffmpeg é‡æ–°ç¼–ç è§†é¢‘æ–‡ä»¶åå†è¯†åˆ«")
                                        elif mean_volume < -40:
                                            log_queue.put(f"      - âš ï¸ æç¤º: éŸ³é¢‘éŸ³é‡è¾ƒä½ï¼Œè¯†åˆ«æ•ˆæœå¯èƒ½å—å½±å“")
                                        else:
                                            log_queue.put(f"      - âœ… éŸ³é¢‘éŸ³é‡æ­£å¸¸")
                                        break
                                    except (ValueError, IndexError):
                                        pass
                except Exception as e:
                    log_queue.put(f"      - âš ï¸ éŸ³é‡æ£€æµ‹å¤±è´¥: {e}")
            else:
                raise FileNotFoundError(f"éŸ³é¢‘æ–‡ä»¶æœªç”Ÿæˆ: {audio_output_path}")

            # è®¡ç®—æ€»è€—æ—¶å¹¶è¾“å‡ºæ€§èƒ½ç»Ÿè®¡
            t_total = time.time() - t_start
            log_queue.put(f"   â±ï¸ [æ€§èƒ½] {p_original.name}: ffprobe={t_ffprobe:.1f}s, cfr={t_cfr:.1f}s, extract={t_extract:.1f}s, total={t_total:.1f}s")

            recognition_task = {
                "original_path": original_file_path,
                "audio_path": str(audio_output_path),
                "video_for_sync": video_to_process
            }
            audio_queue.put(recognition_task)
            log_queue.put(f"   [é¢„å¤„ç†] éŸ³é¢‘æå–æˆåŠŸ: {p_original.name}")

        except Exception as e:
            error_msg = str(e.stderr.strip().split('\n')[-3:]) if hasattr(e, 'stderr') and e.stderr else str(e)
            log_queue.put(f"âŒ [é¢„å¤„ç†] å¤±è´¥: {p_original.name}, åŸå› : {error_msg}")
            progress_queue.put((-1, f"âŒ é¢„å¤„ç†å¤±è´¥: {p_original.name}"))

# --- æµæ°´çº¿é˜¶æ®µ 2ï¼šè¯­éŸ³è¯†åˆ« (GPU/CPU) - åŸå§‹gitç‰ˆæœ¬ ---
def recognition_worker(audio_queue, result_queue, log_queue, config, status_queue, progress_queue, pause_event=None):
    model = None
    processed_count = 0

    try:
        from funasr import AutoModel

        # GPUä¼˜åŒ–é…ç½®
        device = config['device']
        if device == 'cuda':
            import torch
            # è®¾ç½®GPUä¼˜åŒ–
            torch.backends.cudnn.benchmark = True
            torch.backends.cudnn.deterministic = False

            # æ£€æµ‹GPUå†…å­˜å¹¶è®¾ç½®æœ€ä¼˜æ‰¹å¤„ç†å¤§å°
            gpu_memory_gb = torch.cuda.get_device_properties(0).total_memory / (1024**3)
            if gpu_memory_gb >= 24:
                batch_size_s = 25  # é«˜ç«¯GPU
                max_length = 60000
            elif gpu_memory_gb >= 12:
                batch_size_s = 18  # ä¸­ç«¯GPU
                max_length = 45000
            elif gpu_memory_gb >= 8:
                batch_size_s = 12  # å…¥é—¨GPU
                max_length = 30000
            else:
                batch_size_s = 8
                max_length = 20000
            log_queue.put(f"ğŸš€ GPUä¼˜åŒ–: æ˜¾å­˜ {gpu_memory_gb:.1f}GB, æ‰¹å¤„ç†å¤§å° {batch_size_s}")
        else:
            batch_size_s = 15
            max_length = 30000

        log_queue.put("ğŸ”„ FunASRæ¨¡å‹åŠ è½½ä¸­...")
        model = AutoModel(
            model="paraformer-zh",
            vad_model="fsmn-vad",
            punc_model="ct-punc",
            device=device,
            batch_size=batch_size_s,  # åŠ¨æ€æ‰¹å¤„ç†å¤§å°
            max_end_silence_time=800
        )
        log_queue.put("âœ… è¯†åˆ«å¼•æ“åŠ è½½æˆåŠŸã€‚")
        status_queue.put("ready")
    except Exception as e:
        log_queue.put(f"ğŸ’¥ è‡´å‘½é”™è¯¯: æ— æ³•åŠ è½½FunASRæ¨¡å‹! {e}")
        status_queue.put("error")
        return

    try:
        while True:
            if pause_event is not None:
                pause_event.wait()
            task = audio_queue.get()
            if task is None: break

            p_original = Path(task['original_path'])
            log_queue.put(f"   [è¯†åˆ«ä¸­] -> {p_original.name}")
            try:
                # æ£€æŸ¥éŸ³é¢‘æ–‡ä»¶æ˜¯å¦å­˜åœ¨
                audio_path = Path(task['audio_path'])
                if not audio_path.exists():
                    raise FileNotFoundError(f"éŸ³é¢‘æ–‡ä»¶ä¸å­˜åœ¨: {audio_path}")

                log_queue.put(f"      - éŸ³é¢‘æ–‡ä»¶è·¯å¾„: {audio_path}")
                log_queue.put(f"      - éŸ³é¢‘æ–‡ä»¶å¤§å°: {audio_path.stat().st_size} å­—èŠ‚")

                # ä½¿ç”¨ä¼˜åŒ–çš„å‚æ•°è¿›è¡Œè¯†åˆ«
                rec_result = model.generate(
                    input=task['audio_path'],
                    batch_size_s=batch_size_s,  # ä½¿ç”¨åŠ¨æ€æ‰¹å¤„ç†å¤§å°
                    sentence_timestamp=True,
                    disable_pbar=True,  # ç¦ç”¨è¿›åº¦æ¡ï¼Œé¿å…å¤šè¿›ç¨‹ç¯å¢ƒä¸‹çš„é”™è¯¯
                    disable_log=True,   # ç¦ç”¨é¢å¤–æ—¥å¿—
                    max_end_silence_time=800
                )

                # è°ƒè¯•ï¼šæ‰“å°è¯†åˆ«ç»“æœçš„ç»“æ„
                log_queue.put(f"      - è¯†åˆ«ç»“æœç±»å‹: {type(rec_result)}")
                if rec_result:
                    log_queue.put(f"      - è¯†åˆ«ç»“æœé•¿åº¦: {len(rec_result) if isinstance(rec_result, (list, dict)) else 'N/A'}")
                    if isinstance(rec_result, list) and len(rec_result) > 0:
                        log_queue.put(f"      - ç¬¬ä¸€ä¸ªå…ƒç´ ç±»å‹: {type(rec_result[0])}")
                        if isinstance(rec_result[0], dict):
                            log_queue.put(f"      - ç¬¬ä¸€ä¸ªå…ƒç´ é”®: {list(rec_result[0].keys())}")

                task['recognition_result'] = rec_result
                result_queue.put(task)
                log_queue.put(f"   [è¯†åˆ«å®Œæˆ] -> {p_original.name}")

                # å¤„ç†è®¡æ•°å’Œå†…å­˜æ¸…ç†
                processed_count += 1

                # æ¯å¤„ç†3ä¸ªæ–‡ä»¶è¿›è¡Œä¸€æ¬¡å†…å­˜æ¸…ç†
                if processed_count % 3 == 0:
                    if device == 'cuda':
                        import torch
                        torch.cuda.empty_cache()
                    force_garbage_collection(log_queue, 600)
                    monitor_memory_usage(f"è¯†åˆ«ç¬¬{processed_count}ä¸ªæ–‡ä»¶å", log_queue)

            except Exception as e:
                import traceback
                detailed_error = traceback.format_exc()
                log_queue.put(f"âŒ [è¯†åˆ«å¤±è´¥] {p_original.name}, åŸå› : {e}")
                log_queue.put(f"   è¯¦ç»†é”™è¯¯ä¿¡æ¯: {detailed_error}")
                progress_queue.put((-1, f"âŒ è¯†åˆ«å¤±è´¥: {p_original.name}"))

    finally:
        # æ¸…ç†æ¨¡å‹
        if model:
            try:
                del model
                log_queue.put(" [è¯†åˆ«] æ¨¡å‹å·²é‡Šæ”¾")
            except:
                pass

        # GPUå†…å­˜æ¸…ç†
        if device == 'cuda':
            try:
                import torch
                torch.cuda.empty_cache()
                log_queue.put(" [è¯†åˆ«] GPUç¼“å­˜å·²æ¸…ç†")
            except:
                pass

        # æœ€ç»ˆåƒåœ¾å›æ”¶
        force_garbage_collection(log_queue, 0)
        log_queue.put(f" [è¯†åˆ«] å·¥ä½œè¿›ç¨‹ç»“æŸï¼Œå…±å¤„ç† {processed_count} ä¸ªæ–‡ä»¶")

def _soffice_convert_to_pdf(docx_path: Path, pdf_path: Path, log_queue) -> bool:
    """
    ä½¿ç”¨ LibreOffice å°† DOCX è½¬æ¢ä¸º PDFï¼ˆè·¨å¹³å°å…œåº•æ–¹æ¡ˆï¼‰

    Args:
        docx_path: DOCXæ–‡ä»¶è·¯å¾„
        pdf_path: PDFæ–‡ä»¶è·¯å¾„
        log_queue: æ—¥å¿—é˜Ÿåˆ—

    Returns:
        bool: è½¬æ¢æ˜¯å¦æˆåŠŸ
    """
    from shutil import which
    if which("soffice") is None:
        log_queue.put("      - âš ï¸ æ—  LibreOfficeï¼Œè·³è¿‡ PDF å…œåº•è½¬æ¢")
        return False

    cmd = ["soffice", "--headless", "--convert-to", "pdf",
           "--outdir", str(pdf_path.parent), str(docx_path)]

    try:
        result = run_silent(cmd, cwd=str(pdf_path.parent), timeout=60)
        return result.returncode == 0
    except Exception as e:
        log_queue.put(f"      - âš ï¸ LibreOfficeè½¬æ¢å¤±è´¥: {e}")
        return False

# --- æµæ°´çº¿é˜¶æ®µ 3ï¼šåå¤„ç† (CPU) ---
def post_processing_worker(result_queue, log_queue, progress_queue, config, pause_event=None):
    # åœ¨å·¥ä½œè¿›ç¨‹å¯åŠ¨æ—¶ï¼Œå°è¯•å¯¼å…¥ä¸€æ¬¡æ‰€éœ€åº“
    try:
        import docx
    except ImportError:
        docx = None
        log_queue.put("   [åå¤„ç†è­¦å‘Š] æœªå®‰è£… 'python-docx' åº“ï¼ŒDOCXåŠPDFç”ŸæˆåŠŸèƒ½å·²ç¦ç”¨ã€‚")

    try:
        from docx2pdf import convert
    except ImportError:
        convert = None
        log_queue.put("   [åå¤„ç†è­¦å‘Š] æœªå®‰è£… 'docx2pdf' åº“ï¼ŒPDFç”ŸæˆåŠŸèƒ½å·²ç¦ç”¨ã€‚")
    except Exception as e:
        convert = None
        log_queue.put(f"   [åå¤„ç†è­¦å‘Š] å¯¼å…¥ 'docx2pdf' å¤±è´¥: {e}ã€‚PDFç”ŸæˆåŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚")

    while True:
        if pause_event is not None:
            pause_event.wait()
        task = result_queue.get()
        if task is None: break

        p_original = Path(task['original_path'])
        p_video_for_sync = Path(task['video_for_sync'])

        stem = p_video_for_sync.stem
        output_dir = p_original.parent
        log_queue.put(f"   [åå¤„ç†] å¼€å§‹ä¸ºè§†é¢‘ '{p_video_for_sync.name}' ç”Ÿæˆæ–‡ä»¶...")

        try:
            rec_result = task.get('recognition_result')
            srt_path = None

            has_sentence_info = (rec_result and isinstance(rec_result, list) and
                                 len(rec_result) > 0 and isinstance(rec_result[0], dict) and
                                 rec_result[0].get('sentence_info'))

            if not has_sentence_info:
                log_queue.put(f"      - è­¦å‘Š: æ¨¡å‹åœ¨æ–‡ä»¶ '{p_original.name}' ä¸­æœªè¯†åˆ«åˆ°ä»»ä½•æœ‰æ•ˆè¯­éŸ³å†…å®¹ã€‚")

            # --- æå–å®Œæ•´æ–‡æœ¬ ---
            full_text = ''
            if has_sentence_info:
                sentence_list = rec_result[0].get('sentence_info', [])
                full_text = "\n".join(sentence['text'].strip() for sentence in sentence_list)

            # --- ç”Ÿæˆ SRT, TXT, MD, JSON ---
            if config.get('generate_srt'):
                srt_path = output_dir / f"{stem}.srt"
                _write_srt_from_result(rec_result, str(srt_path))
                log_queue.put(f"      - âœ… SRTå­—å¹•å·²ç”Ÿæˆ: {srt_path.name}")

            if config.get('generate_srt_txt'):
                srt_txt_path = output_dir / f"{stem}.srt.txt"  # ä½¿ç”¨ .srt.txt åç¼€ä»¥é¿å…å†²çª
                _write_srt_from_result(rec_result, str(srt_txt_path))
                log_queue.put(f"      - âœ… SRT(.txt)æ ¼å¼å­—å¹•å·²ç”Ÿæˆ: {srt_txt_path.name}")

            if config.get('generate_txt'):
                txt_path = output_dir / f"{stem}.txt"
                with open(txt_path, 'w', encoding='utf-8') as f: f.write(full_text)
                log_queue.put(f"      - âœ… TXTæ–‡æœ¬å·²ç”Ÿæˆ: {txt_path.name}")

            if config.get('generate_txt_md'):
                txt_md_path = output_dir / f"{stem}.md.txt"
                with open(txt_md_path, 'w', encoding='utf-8') as f:
                    f.write(f"# {stem}\n\n")
                    f.write(full_text)
                log_queue.put(f"      - âœ… TXT(Markdownæ ¼å¼)æ–‡ä»¶å·²ç”Ÿæˆ: {txt_md_path.name}")

            if config.get('generate_json'):
                json_path = output_dir / f"{stem}.json"
                with open(json_path, 'w', encoding='utf-8') as f: json.dump(rec_result, f, ensure_ascii=False, indent=2)
                log_queue.put(f"      - âœ… JSONæ•°æ®å·²ç”Ÿæˆ: {json_path.name}")

            # --- DOCX å’Œ PDF ç”Ÿæˆæµç¨‹ ---
            needs_docx = config.get('generate_docx') or config.get('generate_pdf')
            docx_path = None
            if needs_docx:
                if docx:
                    try:
                        docx_path = output_dir / f"{stem}.docx"
                        document = docx.Document()
                        document.add_heading(stem, level=1)
                        document.add_paragraph(full_text)
                        document.save(str(docx_path))
                        if config.get('generate_docx'):
                            log_queue.put(f"      - âœ… DOCXæ–‡ä»¶å·²ç”Ÿæˆ: {docx_path.name}")
                    except Exception as e:
                        log_queue.put(f"      - âŒ ç”ŸæˆDOCXæ–‡ä»¶æ—¶å‡ºé”™: {e}")
                        docx_path = None

            # --- ä» DOCX è½¬æ¢åˆ° PDF ---
            if config.get('generate_pdf'):
                if docx_path and docx_path.exists():
                    pdf_path = output_dir / f"{stem}.pdf"
                    pdf_generated = False

                    # ä¼˜å…ˆå°è¯• docx2pdf (Windows)
                    if convert:
                        try:
                            log_queue.put(f"      - æ­£åœ¨ä»DOCXè½¬æ¢ä¸ºPDFï¼Œè¯·ç¨å€™...")
                            convert(str(docx_path), str(pdf_path))
                            log_queue.put(f"      - âœ… PDFæ–‡ä»¶å·²ç”Ÿæˆ: {pdf_path.name}")
                            pdf_generated = True
                        except Exception as e:
                            log_queue.put(f"      - âš ï¸ docx2pdf è½¬æ¢å¤±è´¥: {e}")
                            log_queue.put("         -> å°è¯•ä½¿ç”¨ LibreOffice å…œåº•...")

                    # å¦‚æœ docx2pdf å¤±è´¥æˆ–ä¸å¯ç”¨ï¼Œå°è¯• LibreOffice
                    if not pdf_generated:
                        if _soffice_convert_to_pdf(docx_path, pdf_path, log_queue):
                            log_queue.put(f"      - âœ… PDFæ–‡ä»¶å·²ç”Ÿæˆ(LibreOffice): {pdf_path.name}")
                            pdf_generated = True
                        else:
                            log_queue.put("      - âŒ PDFè½¬æ¢å¤±è´¥ï¼ˆdocx2pdf å’Œ LibreOffice éƒ½ä¸å¯ç”¨ï¼‰")
                            log_queue.put("         [æç¤º] è¯·å®‰è£… Microsoft Word æˆ– LibreOfficeã€‚")

                elif needs_docx:
                    log_queue.put("      - âš ï¸ è·³è¿‡PDFç”Ÿæˆï¼šå‰ç½®çš„DOCXæ–‡ä»¶æœªèƒ½æˆåŠŸåˆ›å»ºã€‚")

            # --- æ¸…ç†ä¸´æ—¶çš„DOCXæ–‡ä»¶ ---
            if docx_path and docx_path.exists() and config.get('generate_pdf') and not config.get('generate_docx'):
                # ä½¿ç”¨ä¼˜åŒ–çš„æ–‡ä»¶æ¸…ç†å·¥å…·
                success = file_cleaner.safe_remove_file(str(docx_path), log_queue.put)
                if not success:
                    log_queue.put(f"      - âš ï¸ ä¸­é—´æ–‡ä»¶æ¸…ç†å¤±è´¥ï¼Œå°†åœ¨ç¨‹åºé€€å‡ºæ—¶å¼ºåˆ¶æ¸…ç†: {docx_path.name}")

            # --- å­—å¹•ç²¾æ ¡ ---
            if config.get('ffsubsync_enabled') and srt_path and srt_path.exists() and srt_path.stat().st_size > 0:
                log_queue.put(f"      - å¼€å§‹å¯¹ '{srt_path.name}' è¿›è¡Œ ffsubsync å­—å¹•ç²¾æ ¡...")

                # ã€æ–°å¢ã€‘å¦‚æœä½¿ç”¨ Silero VADï¼Œç¡®ä¿æ¨¡å‹å¯ç”¨
                vad_method = config.get('ffsubsync_vad', 'silero')
                if vad_method == 'silero':
                    log_queue.put(f"         -> æ£€æŸ¥ Silero VAD æ¨¡å‹...")
                    try:
                        ensure_silero_for_ffsubsync()
                        log_queue.put(f"         -> âœ… Silero æ¨¡å‹å·²å°±ç»ª")
                    except Exception as e:
                        log_queue.put(f"         -> âš ï¸ Silero æ¨¡å‹æ£€æŸ¥å¤±è´¥: {e}")
                        log_queue.put(f"         -> å°†å°è¯•ç»§ç»­æ‰§è¡Œï¼ˆå¯èƒ½ä½¿ç”¨ PyTorch Hubï¼‰")

                synced_srt_path = output_dir / f"{stem}_Ffsub.srt"

                # æ„å»º ffsubsync å‘½ä»¤
                relative_video_path = p_video_for_sync.name
                relative_srt_path = srt_path.name
                relative_synced_path = synced_srt_path.name

                # åŸºç¡€å‘½ä»¤
                sync_cmd = ['ffsubsync', str(relative_video_path), '-i', str(relative_srt_path), '-o', str(relative_synced_path)]

                # ã€æ–°å¢ã€‘æ·»åŠ  VAD ç®—æ³•é€‰æ‹©
                vad_method = config.get('ffsubsync_vad', 'silero')  # é»˜è®¤ä½¿ç”¨ silero
                if vad_method in ['webrtc', 'auditok', 'silero']:
                    sync_cmd.extend(['--vad', vad_method])
                    log_queue.put(f"         -> ä½¿ç”¨ VAD ç®—æ³•: {vad_method}")

                # ã€æ–°å¢ã€‘æ·»åŠ æœ€å¤§åç§»é‡é™åˆ¶ï¼ˆæé«˜å¤„ç†é€Ÿåº¦ï¼‰
                max_offset = config.get('ffsubsync_max_offset', 60)
                if max_offset > 0:
                    sync_cmd.extend(['--max-offset-seconds', str(max_offset)])
                    log_queue.put(f"         -> æœ€å¤§åç§»é‡: {max_offset}ç§’")

                # æ‰§è¡Œ ffsubsync
                log_queue.put(f"         -> å‘½ä»¤: {' '.join(sync_cmd)}")
                result = run_silent(sync_cmd, cwd=output_dir)

                if synced_srt_path.exists() and synced_srt_path.stat().st_size > 0:
                    try:
                        srt_path.unlink()
                        log_queue.put(f"      - âœ… ffsubsync ç²¾æ ¡æˆåŠŸï¼è¾“å‡ºæ–‡ä»¶: {synced_srt_path.name}")

                        # ã€ä¼˜åŒ–ã€‘è§£æ ffsubsync è¾“å‡ºä»¥æå–åç§»ä¿¡æ¯
                        if result.stdout:
                            for line in result.stdout.split('\n'):
                                if 'offset' in line.lower() or 'shift' in line.lower():
                                    log_queue.put(f"         -> {line.strip()}")

                        # ã€æ–°å¢ã€‘å¦‚æœå¯ç”¨äº† .srt.txt ç”Ÿæˆï¼Œä½¿ç”¨æ ¡å‡†åçš„å­—å¹•å†…å®¹æ›´æ–°å®ƒ
                        if config.get('generate_srt_txt'):
                            srt_txt_path = output_dir / f"{stem}.srt.txt"
                            try:
                                # å¤åˆ¶æ ¡å‡†åçš„ SRT å†…å®¹åˆ° .srt.txt
                                shutil.copy2(str(synced_srt_path), str(srt_txt_path))
                                log_queue.put(f"      - âœ… å·²ä½¿ç”¨æ ¡å‡†åçš„å­—å¹•æ›´æ–°: {srt_txt_path.name}")
                            except Exception as e:
                                log_queue.put(f"      - è­¦å‘Š: æ›´æ–° .srt.txt æ–‡ä»¶å¤±è´¥: {e}")

                    except OSError as e:
                        log_queue.put(f"      - è­¦å‘Š: ffsubsync æˆåŠŸï¼Œä½†åˆ é™¤åŸå§‹SRTå¤±è´¥: {e}")
                else:
                    # ã€ä¼˜åŒ–ã€‘æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    error_details = result.stderr.strip() if result.stderr else "æœªçŸ¥é”™è¯¯"
                    log_queue.put(f"      - âš ï¸ ffsubsync æ‰§è¡Œå¤±è´¥æˆ–æœªç”Ÿæˆæœ‰æ•ˆæ–‡ä»¶ã€‚ä¿ç•™åŸå§‹å­—å¹•ã€‚")
                    log_queue.put(f"         -> è¿”å›ç : {result.returncode}")
                    if error_details:
                        # åªæ˜¾ç¤ºæœ€åå‡ è¡Œå…³é”®é”™è¯¯ä¿¡æ¯
                        error_lines = error_details.split('\n')[-5:]
                        for err_line in error_lines:
                            if err_line.strip():
                                log_queue.put(f"         -> é”™è¯¯: {err_line.strip()}")

            # --- æ¸…ç†ä¸´æ—¶æ–‡ä»¶ ---
            p_audio_temp = Path(task['audio_path'])
            # ä½¿ç”¨ä¼˜åŒ–çš„æ–‡ä»¶æ¸…ç†å·¥å…·
            success = file_cleaner.safe_remove_file(str(p_audio_temp), log_queue.put)
            if not success:
                log_queue.put(f"      - âš ï¸ WAVä¸´æ—¶æ–‡ä»¶æ¸…ç†å¤±è´¥ï¼Œå°†åœ¨ç¨‹åºé€€å‡ºæ—¶å¼ºåˆ¶æ¸…ç†: {p_audio_temp.name}")

            if p_original != p_video_for_sync:
                log_queue.put(f"      - CFRè½¬æ¢å®Œæˆã€‚åŸå§‹æ–‡ä»¶å’Œæ–°çš„CFRæ–‡ä»¶å‡å·²ä¿ç•™: {p_video_for_sync.name}")

            progress_queue.put((1, f"âœ… å¤„ç†æˆåŠŸ: {p_original.name}, å·²ç”Ÿæˆæ‰€é€‰æ ¼å¼æ–‡ä»¶ã€‚"))

        except Exception as e:
            error_msg = traceback.format_exc()
            log_queue.put(f"âŒ [åå¤„ç†] å¤±è´¥: {p_original.name}, åŸå› : {error_msg}")
            progress_queue.put((-1, f"âŒ åå¤„ç†å¤±è´¥: {p_original.name}"))
